\hypertarget{PeripheralSPIImpl_8h}{}\section{/home/luk/\+Work/\+Communication\+Module/include/\+Peripheral\+S\+P\+I\+Impl.h File Reference}
\label{PeripheralSPIImpl_8h}\index{/home/luk/\+Work/\+Communication\+Module/include/\+Peripheral\+S\+P\+I\+Impl.\+h@{/home/luk/\+Work/\+Communication\+Module/include/\+Peripheral\+S\+P\+I\+Impl.\+h}}


S\+PI Implementation of the Peripheral\+Interface.  


{\ttfamily \#include \char`\"{}include/\+Peripheral.\+h\char`\"{}}\newline
{\ttfamily \#include $<$stddef.\+h$>$}\newline
\subsection*{Classes}
\begin{DoxyCompactItemize}
\item 
struct \mbox{\hyperlink{structSPISlave}{S\+P\+I\+Slave}}
\item 
struct \mbox{\hyperlink{structSPIConfig}{S\+P\+I\+Config}}
\end{DoxyCompactItemize}
\subsection*{Typedefs}
\begin{DoxyCompactItemize}
\item 
typedef struct \mbox{\hyperlink{structSPISlave}{S\+P\+I\+Slave}} \mbox{\hyperlink{PeripheralSPIImpl_8h_a9d0892c7ea383464d226e2fd2e829130}{S\+P\+I\+Slave}}
\item 
typedef struct \mbox{\hyperlink{structSPIConfig}{S\+P\+I\+Config}} \mbox{\hyperlink{PeripheralSPIImpl_8h_a0dec1d6175dde82f7d668237ebaf5e8a}{S\+P\+I\+Config}}
\end{DoxyCompactItemize}
\subsection*{Enumerations}
\begin{DoxyCompactItemize}
\item 
enum \mbox{\hyperlink{PeripheralSPIImpl_8h_a5486c45e535f2aaba01044ca55db9d3b}{S\+P\+I\+Control\+Register\+Parameters}} \{ \newline
{\bfseries S\+P\+I\+\_\+\+D\+A\+T\+A\+\_\+\+O\+R\+D\+E\+R\+\_\+\+M\+S\+B\+\_\+\+F\+I\+R\+ST}, 
{\bfseries S\+P\+I\+\_\+\+D\+A\+T\+A\+\_\+\+O\+R\+D\+E\+R\+\_\+\+L\+S\+B\+\_\+\+F\+I\+R\+ST}, 
{\bfseries S\+P\+I\+\_\+\+C\+L\+O\+C\+K\+\_\+\+R\+A\+T\+E\+\_\+\+D\+I\+V\+I\+D\+E\+R\+\_\+4}, 
{\bfseries S\+P\+I\+\_\+\+C\+L\+O\+C\+K\+\_\+\+R\+A\+T\+E\+\_\+\+D\+I\+V\+I\+D\+E\+R\+\_\+8}, 
\newline
{\bfseries S\+P\+I\+\_\+\+C\+L\+O\+C\+K\+\_\+\+R\+A\+T\+E\+\_\+\+D\+I\+V\+I\+D\+E\+R\+\_\+16}, 
{\bfseries S\+P\+I\+\_\+\+C\+L\+O\+C\+K\+\_\+\+R\+A\+T\+E\+\_\+\+D\+I\+V\+I\+D\+E\+R\+\_\+32}, 
{\bfseries S\+P\+I\+\_\+\+C\+L\+O\+C\+K\+\_\+\+R\+A\+T\+E\+\_\+\+D\+I\+V\+I\+D\+E\+R\+\_\+64}, 
{\bfseries S\+P\+I\+\_\+\+C\+L\+O\+C\+K\+\_\+\+R\+A\+T\+E\+\_\+\+D\+I\+V\+I\+D\+E\+R\+\_\+128}, 
\newline
{\bfseries S\+P\+I\+\_\+\+M\+O\+D\+E\+\_\+0}, 
{\bfseries S\+P\+I\+\_\+\+M\+O\+D\+E\+\_\+1}, 
{\bfseries S\+P\+I\+\_\+\+M\+O\+D\+E\+\_\+2}, 
{\bfseries S\+P\+I\+\_\+\+M\+O\+D\+E\+\_\+3}, 
\newline
{\bfseries S\+P\+I\+\_\+\+I\+D\+L\+E\+\_\+\+S\+I\+G\+N\+A\+L\+\_\+\+L\+OW}, 
{\bfseries S\+P\+I\+\_\+\+I\+D\+L\+E\+\_\+\+S\+I\+G\+N\+A\+L\+\_\+\+H\+I\+GH}
 \}
\end{DoxyCompactItemize}
\subsection*{Functions}
\begin{DoxyCompactItemize}
\item 
size\+\_\+t \mbox{\hyperlink{PeripheralSPIImpl_8h_a6ec819042ec3994cdd010d9c16df0d78}{Peripheral\+Interface\+S\+P\+I\+\_\+get\+A\+D\+T\+Size}} (void)
\item 
Peripheral\+Interface \mbox{\hyperlink{PeripheralSPIImpl_8h_a62ebc8569909486b133842da022a0f28}{Peripheral\+Interface\+S\+P\+I\+\_\+create\+New}} (uint8\+\_\+t $\ast$const memory, const \mbox{\hyperlink{structSPIConfig}{S\+P\+I\+Config}} $\ast$const spi\+Config)
\end{DoxyCompactItemize}


\subsection{Detailed Description}
S\+PI Implementation of the Peripheral\+Interface. 

This header provides all declarations needed to initialize the driver for the S\+PI hardware implementation for the Peripheral\+Interface interface. The implementation is supposed to support all atmega platforms by just correctly defining the \mbox{\hyperlink{structSPIConfig}{S\+P\+I\+Config}} and \mbox{\hyperlink{structSPISlave}{S\+P\+I\+Slave}} data types. Here an example configuration for an atmega32u4 where the io pin for the connected slave is the fifth pin (we start counting at 0) on port B


\begin{DoxyCode}
\mbox{\hyperlink{structSPISlave}{SPISlave}} mrf\_spi\_client = \{
    .\mbox{\hyperlink{structSPISlave_abbc4e8f0ccaa89da51ca0e4ff24ad7e9}{data\_register}} = &PORTB,
    .data\_direction\_register = &DDRB,
    .select\_chip\_pin\_number = 4,
    .data\_order = SPI\_DATA\_ORDER\_MSB\_FIRST,
    .spi\_mode = SPI\_MODE\_0,
    .idle\_signal = SPI\_IDLE\_SIGNAL\_HIGH,
    .clock\_rate\_divider = SPI\_CLOCK\_RATE\_DIVIDER\_64,
\};
\end{DoxyCode}


And the configuration for the spi hardware interface on that platform after including {\ttfamily $<$avr/io.\+h$>$}


\begin{DoxyCode}
\mbox{\hyperlink{structSPIConfig}{SPIConfig}} spi\_config = \{
  .data\_register = &SPDR,
  .clock\_pin = PORTB1,
  .miso\_pin = PORTB3,
  .mosi\_pin = PORTB2,
  .slave\_select\_pin = PORTB0,
  .io\_lines\_data\_direction\_register = &DDRB,
  .io\_lines\_data\_register = &PORTB,
  .status\_register = &SPSR,
  .control\_register = &SPCR,
\};
\end{DoxyCode}
 

\subsection{Typedef Documentation}
\mbox{\Hypertarget{PeripheralSPIImpl_8h_a0dec1d6175dde82f7d668237ebaf5e8a}\label{PeripheralSPIImpl_8h_a0dec1d6175dde82f7d668237ebaf5e8a}} 
\index{Peripheral\+S\+P\+I\+Impl.\+h@{Peripheral\+S\+P\+I\+Impl.\+h}!S\+P\+I\+Config@{S\+P\+I\+Config}}
\index{S\+P\+I\+Config@{S\+P\+I\+Config}!Peripheral\+S\+P\+I\+Impl.\+h@{Peripheral\+S\+P\+I\+Impl.\+h}}
\subsubsection{\texorpdfstring{S\+P\+I\+Config}{SPIConfig}}
{\footnotesize\ttfamily typedef struct \mbox{\hyperlink{structSPIConfig}{S\+P\+I\+Config}}  \mbox{\hyperlink{structSPIConfig}{S\+P\+I\+Config}}}

Configuration struct for the hardware spi interface. For information on how to set this up, look at the example above and your microcontrollers datasheet. \mbox{\Hypertarget{PeripheralSPIImpl_8h_a9d0892c7ea383464d226e2fd2e829130}\label{PeripheralSPIImpl_8h_a9d0892c7ea383464d226e2fd2e829130}} 
\index{Peripheral\+S\+P\+I\+Impl.\+h@{Peripheral\+S\+P\+I\+Impl.\+h}!S\+P\+I\+Slave@{S\+P\+I\+Slave}}
\index{S\+P\+I\+Slave@{S\+P\+I\+Slave}!Peripheral\+S\+P\+I\+Impl.\+h@{Peripheral\+S\+P\+I\+Impl.\+h}}
\subsubsection{\texorpdfstring{S\+P\+I\+Slave}{SPISlave}}
{\footnotesize\ttfamily typedef struct \mbox{\hyperlink{structSPISlave}{S\+P\+I\+Slave}}  \mbox{\hyperlink{structSPISlave}{S\+P\+I\+Slave}}}

Software representation of the spi slave connected to the hosts spi hardware interface 

\subsection{Enumeration Type Documentation}
\mbox{\Hypertarget{PeripheralSPIImpl_8h_a5486c45e535f2aaba01044ca55db9d3b}\label{PeripheralSPIImpl_8h_a5486c45e535f2aaba01044ca55db9d3b}} 
\index{Peripheral\+S\+P\+I\+Impl.\+h@{Peripheral\+S\+P\+I\+Impl.\+h}!S\+P\+I\+Control\+Register\+Parameters@{S\+P\+I\+Control\+Register\+Parameters}}
\index{S\+P\+I\+Control\+Register\+Parameters@{S\+P\+I\+Control\+Register\+Parameters}!Peripheral\+S\+P\+I\+Impl.\+h@{Peripheral\+S\+P\+I\+Impl.\+h}}
\subsubsection{\texorpdfstring{S\+P\+I\+Control\+Register\+Parameters}{SPIControlRegisterParameters}}
{\footnotesize\ttfamily enum \mbox{\hyperlink{PeripheralSPIImpl_8h_a5486c45e535f2aaba01044ca55db9d3b}{S\+P\+I\+Control\+Register\+Parameters}}}

These values are used to configure the spi hardware interface

Values from a set of names sharing the same biggest possible prefix are mutually exclusive. E.\+g. you can obviously only use one single value for your clock rate divider. To find out which set of values you need to use for your use case, have look at the datasheet of the peripheral device you want to interact with. Choose a clock rate divider to match a supported clock rate of your peripheral device depending on the clock rate of your microcontroller. E.\+g. your peripheral device datasheet recommends a clock rate of 1 M\+Hz and your microcontroller runs at 16\+M\+Hz, so you choose S\+P\+I\+\_\+\+C\+L\+O\+C\+K\+\_\+\+R\+A\+T\+E\+\_\+\+D\+I\+V\+I\+D\+E\+R\+\_\+16. 

\subsection{Function Documentation}
\mbox{\Hypertarget{PeripheralSPIImpl_8h_a62ebc8569909486b133842da022a0f28}\label{PeripheralSPIImpl_8h_a62ebc8569909486b133842da022a0f28}} 
\index{Peripheral\+S\+P\+I\+Impl.\+h@{Peripheral\+S\+P\+I\+Impl.\+h}!Peripheral\+Interface\+S\+P\+I\+\_\+create\+New@{Peripheral\+Interface\+S\+P\+I\+\_\+create\+New}}
\index{Peripheral\+Interface\+S\+P\+I\+\_\+create\+New@{Peripheral\+Interface\+S\+P\+I\+\_\+create\+New}!Peripheral\+S\+P\+I\+Impl.\+h@{Peripheral\+S\+P\+I\+Impl.\+h}}
\subsubsection{\texorpdfstring{Peripheral\+Interface\+S\+P\+I\+\_\+create\+New()}{PeripheralInterfaceSPI\_createNew()}}
{\footnotesize\ttfamily Peripheral\+Interface Peripheral\+Interface\+S\+P\+I\+\_\+create\+New (\begin{DoxyParamCaption}\item[{uint8\+\_\+t $\ast$const}]{memory,  }\item[{const \mbox{\hyperlink{structSPIConfig}{S\+P\+I\+Config}} $\ast$const}]{spi\+Config }\end{DoxyParamCaption})}

The \mbox{\hyperlink{structSPIConfig}{S\+P\+I\+Config}} struct handed over to this function needs be alive as long as you are using this Peripheral\+Interface. \mbox{\Hypertarget{PeripheralSPIImpl_8h_a6ec819042ec3994cdd010d9c16df0d78}\label{PeripheralSPIImpl_8h_a6ec819042ec3994cdd010d9c16df0d78}} 
\index{Peripheral\+S\+P\+I\+Impl.\+h@{Peripheral\+S\+P\+I\+Impl.\+h}!Peripheral\+Interface\+S\+P\+I\+\_\+get\+A\+D\+T\+Size@{Peripheral\+Interface\+S\+P\+I\+\_\+get\+A\+D\+T\+Size}}
\index{Peripheral\+Interface\+S\+P\+I\+\_\+get\+A\+D\+T\+Size@{Peripheral\+Interface\+S\+P\+I\+\_\+get\+A\+D\+T\+Size}!Peripheral\+S\+P\+I\+Impl.\+h@{Peripheral\+S\+P\+I\+Impl.\+h}}
\subsubsection{\texorpdfstring{Peripheral\+Interface\+S\+P\+I\+\_\+get\+A\+D\+T\+Size()}{PeripheralInterfaceSPI\_getADTSize()}}
{\footnotesize\ttfamily size\+\_\+t Peripheral\+Interface\+S\+P\+I\+\_\+get\+A\+D\+T\+Size (\begin{DoxyParamCaption}\item[{void}]{ }\end{DoxyParamCaption})}

Use this to find out how much memory you need to provide to the create function.

\begin{DoxyReturn}{Returns}
The size of the S\+PI implementation. 
\end{DoxyReturn}
